{"type":"documentation","uses_katex":false,"breadcrumbs":[{"name":"patricia-tree","href":"../../index.html","kind":"page"},{"name":"PatriciaTree","href":"../index.html","kind":"module"},{"name":"HashedValue","href":"#","kind":"module"}],"toc":[],"source_anchor":null,"preamble":"<p>Generic implementation of <a href=\"../module-type-HASHED_VALUE/index.html\"><code>HASHED_VALUE</code></a>. Uses <a href=\"https://ocaml.org/api/Hashtbl.html#VALhash\"><code>Hashtbl.hash</code></a> for hashing and physical equality for equality. Note that this may lead to maps of different types having the same identifier (<a href=\"../MakeHashconsedMap/index.html#val-to_int\"><code>MakeHashconsedMap.to_int</code></a>), see the documentation of <a href=\"../module-type-HASHED_VALUE/index.html#val-polyeq\"><code>HASHED_VALUE.polyeq</code></a> for details on this.</p>","content":"<div class=\"odoc-spec\"><div class=\"spec type anchored\" id=\"type-t\"><a href=\"#type-t\" class=\"anchor\"></a><code><span><span class=\"keyword\">type</span> <span>'a t</span></span><span> = <span class=\"type-var\">'a</span></span></code></div><div class=\"spec-doc\"><p>The type of values for a hash-consed maps.</p><p>Unlike <a href=\"../module-type-VALUE/index.html#type-t\"><code>VALUE.t</code></a>, <b>hash-consed values should be immutable</b>. Or, if they do mutate, they must not change their <a href=\"#val-hash\"><code>hash</code></a> value, and still be equal to the same values via <a href=\"#val-polyeq\"><code>polyeq</code></a></p></div></div><div class=\"odoc-spec\"><div class=\"spec value anchored\" id=\"val-hash\"><a href=\"#val-hash\" class=\"anchor\"></a><code><span><span class=\"keyword\">val</span> hash : <span><span><span class=\"type-var\">'map</span> <a href=\"#type-t\">t</a></span> <span class=\"arrow\">&#45;&gt;</span></span> int</span></code></div><div class=\"spec-doc\"><p><code>hash v</code> should return an integer hash for the value <code>v</code>. It is used for <a href=\"../index.html#hash_consed\" title=\"hash_consed\">hash-consing</a>.</p><p>Hashing should be fast, avoid mapping too many values to the same integer and compatible with <a href=\"#val-polyeq\"><code>polyeq</code></a> (equal values must have the same hash: <code>polyeq v1 v2 = true ==&gt; hash v1 = hash v2</code>).</p></div></div><div class=\"odoc-spec\"><div class=\"spec value anchored\" id=\"val-polyeq\"><a href=\"#val-polyeq\" class=\"anchor\"></a><code><span><span class=\"keyword\">val</span> polyeq : <span><span><span class=\"type-var\">'a</span> <a href=\"#type-t\">t</a></span> <span class=\"arrow\">&#45;&gt;</span></span> <span><span><span class=\"type-var\">'b</span> <a href=\"#type-t\">t</a></span> <span class=\"arrow\">&#45;&gt;</span></span> bool</span></code></div><div class=\"spec-doc\"><p>Polymorphic equality on values.</p><p><b>WARNING: if <code>polyeq a b</code> is true, then casting <code>b</code> to the type of <code>a</code> (and <code>a</code> to the type of <code>b</code>) must be type-safe.</b> Eg. if <code>a : t1 t</code> and <code>b : t2 t</code> yield <code>polyeq a b = true</code>, then <code>let a' : t2 t = Obj.magic a</code> and <code>let b' : t1 t = Obj.magic b</code> must be safe.</p><p>Examples of safe implementations include:</p><ul><li><p>Having a type <code>'a t</code> which doesn't depend on <code>'a</code>, in which case casting form <code>'a t</code> to <code>'b t</code> is always safe:</p><pre class=\"language-ocaml\"><code>type _ t = foo\u000Alet cast : type a b. a t -&gt; b t = fun x -&gt; x\u000Alet polyeq : type a b. a t -&gt; b t -&gt; bool = fun x y -&gt; x = y</code></pre></li><li><p>Using a GADT type and examining its constructors to only return <code>true</code> when the constructors are equal:</p><pre class=\"language-ocaml\"><code>type _ t =\u000A    | T_Int : int -&gt; int t\u000A    | T_Bool : bool -&gt; bool t\u000Alet polyeq : type a b. a t -&gt; b t -&gt; bool = fun x y -&gt;\u000A    match x, y with\u000A    | T_Int i, T_Int j -&gt; i = j (* Here type a = b = int, we can return true *)\u000A    | T_Bool i, T_Bool j -&gt; i &amp;&amp; j (* same here, but with a = b = bool *)\u000A    | _ -&gt; false (* never return true on heterogeneous cases. *)</code></pre></li><li><p>Using physical equality:</p><pre class=\"language-ocaml\"><code>let polyeq a b = a == Obj.magic b</code></pre><p>While this contains an <code>Obj.magic</code>, it is still type safe (OCaml just compares the immediate values) and we can safely cast values from one type to the other if they satisfy this (since they are already physically equal).</p><p>This is the implementation used in <a href=\"#\"><code>HashedValue</code></a>. Note however that using this function can lead to <b>identifiers no longer being unique across types</b>. They will still be unique and behave as expected within a certain type, but since some values of different types can physically equal, we may have identifer clashes:</p><pre class=\"language-ocaml\"><code># 97 == Obj.magic 'a';;\u000A- : bool = true</code></pre><pre class=\"language-ocaml\"><code>module HMap = MakeHashconsedMap(struct\u000A    type t = int\u000A    let to_int x = x\u000Aend)(HashedValue)()</code></pre><pre class=\"language-ocaml\"><code># let m1 = HMap.singleton 5 97;;\u000Aval m1 : int HMap.t = &lt;abstr&gt;\u000A# let m2 = HMap.singleton 5 'a';;\u000Aval m2 : char HMap.t = &lt;abstr&gt;\u000A# HMap.to_int m1 = HMap.to_int m2;;\u000A- : bool = true</code></pre><p>This can cause problems if you wish to use identifiers of different map types together:</p><pre class=\"language-ocaml\"><code>type any = Any : 'a HMap.t -&gt; any\u000Amodule MapOfMaps = MakeMap(struct\u000A  type t = any\u000A  let to_int (Any x) = HMap.to_int x\u000Aend)</code></pre><p>Using this can lead to unexpected behaviors: in the following <code>m3</code> has cardinal 1, the <code>m1-&gt;&quot;foo&quot;</code> binding has been overwritten</p><pre class=\"language-ocaml\"><code># let m3 = MapOfMaps.of_list [ (Any m1, &quot;foo&quot;); (Any m2, &quot;bar&quot;) ]\u000Aval m3 : string MapOfMaps.t = &lt;abstr&gt;\u000A# MapOfMaps.to_list m3\u000A- : (any * string) list = [(Any &lt;abstr&gt;, &quot;bar&quot;)]</code></pre><p>This issue does not happen with the two previous variants, since they both only return true on the same types.</p></li></ul></div></div>"}
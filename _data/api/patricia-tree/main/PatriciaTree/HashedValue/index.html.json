{"type":"documentation","uses_katex":false,"breadcrumbs":[{"name":"patricia-tree","href":"../../index.html","kind":"page"},{"name":"PatriciaTree","href":"../index.html","kind":"module"},{"name":"HashedValue","href":"#","kind":"module"}],"toc":[],"source_anchor":null,"preamble":"<p>Generic implementation of <a href=\"../module-type-HASHED_VALUE/index.html\"><code>HASHED_VALUE</code></a>. Uses <a href=\"https://ocaml.org/api/Hashtbl.html#VALhash\"><code>Hashtbl.hash</code></a> for hashing and physical equality for equality. Note that this may lead to maps of different types having the same identifier (<a href=\"../MakeHashconsedMap/index.html#val-get_id\"><code>MakeHashconsedMap.get_id</code></a>), see the documentation of <a href=\"../module-type-HASHED_VALUE/index.html#val-polyeq\"><code>HASHED_VALUE.polyeq</code></a> for details on this.</p>","content":"<div class=\"odoc-spec\"><div class=\"spec type anchored\" id=\"type-t\"><a href=\"#type-t\" class=\"anchor\"></a><code><span><span class=\"keyword\">type</span> <span>'a t</span></span><span> = <span class=\"type-var\">'a</span></span></code></div><div class=\"spec-doc\"><p>The type of values for a hash-consed maps.</p><p>Unlike <a href=\"../module-type-VALUE/index.html#type-t\"><code>VALUE.t</code></a>, <b>hash-consed values should be immutable</b>. Or, if they do mutate, they must not change their <a href=\"#val-hash\"><code>hash</code></a> value, and still be equal to the same values via <a href=\"#val-polyeq\"><code>polyeq</code></a></p></div></div><div class=\"odoc-spec\"><div class=\"spec value anchored\" id=\"val-hash\"><a href=\"#val-hash\" class=\"anchor\"></a><code><span><span class=\"keyword\">val</span> hash : <span><span><span class=\"type-var\">'map</span> <a href=\"#type-t\">t</a></span> <span class=\"arrow\">&#45;&gt;</span></span> int</span></code></div><div class=\"spec-doc\"><p><code>hash v</code> should return an integer hash for the value <code>v</code>. It is used for <a href=\"../index.html#hash_consed\" title=\"hash_consed\">hash-consing</a>.</p><p>Hashing should be fast, avoid mapping too many values to the same integer and compatible with <a href=\"#val-polyeq\"><code>polyeq</code></a> (equal values must have the same hash: <code>polyeq v1 v2 = true ==&gt; hash v1 = hash v2</code>).</p></div></div><div class=\"odoc-spec\"><div class=\"spec value anchored\" id=\"val-polyeq\"><a href=\"#val-polyeq\" class=\"anchor\"></a><code><span><span class=\"keyword\">val</span> polyeq : <span><span><span class=\"type-var\">'a</span> <a href=\"#type-t\">t</a></span> <span class=\"arrow\">&#45;&gt;</span></span> <span><span><span class=\"type-var\">'b</span> <a href=\"#type-t\">t</a></span> <span class=\"arrow\">&#45;&gt;</span></span> bool</span></code></div><div class=\"spec-doc\"><p>Polymorphic equality on values.</p><p><b>WARNING: if <code>polyeq a b</code> is true, then casting <code>b</code> to the type of <code>a</code> (and <code>a</code> to the type of <code>b</code>) must be type-safe.</b> Eg. if <code>a : t1 t</code> and <code>b : t2 t</code> yield <code>polyeq a b = true</code>, then <code>let a' : t2 t = Obj.magic a</code> and <code>let b' : t1 t = Obj.magic b</code> must be safe.</p><p>Examples of safe implementations include:</p><ul><li><p>Having a type <code>'a t</code> which doesn't depend on <code>'a</code>, in which case casting form <code>'a t</code> to <code>'b t</code> is always safe:</p><pre class=\"language-ocaml\"><code>type _ t = foo\u000Alet cast : type a b. a t -&gt; b t = fun x -&gt; x\u000Alet polyeq : type a b. a t -&gt; b t -&gt; bool = fun x y -&gt; x = y</code></pre></li><li><p>Using a GADT type and examining its constructors to only return <code>true</code> when the constructors are equal:</p><pre class=\"language-ocaml\"><code>type _ t =\u000A    | T_Int : int -&gt; int t\u000A    | T_Bool : bool -&gt; bool t\u000Alet polyeq : type a b. a t -&gt; b t -&gt; bool = fun x y -&gt;\u000A    match x, y with\u000A    | T_Int i, T_Int j -&gt; i = j (* Here type a = b = int, we can return true *)\u000A    | T_Bool i, T_Bool j -&gt; i &amp;&amp; j (* same here, but with a = b = bool *)\u000A    | _ -&gt; false (* never return true on heterogeneous cases. *)</code></pre></li><li><p>Using physical equality:</p><pre class=\"language-ocaml\"><code>let polyeq a b = a == Obj.magic b</code></pre><p>While this contains an <code>Obj.magic</code>, it is still type safe (OCaml just compares the immediate values) and we can safely cast values from one type to the other if they satisfy this (since they are already physically equal).</p><p>This is the implementation used in <a href=\"#\"><code>HashedValue</code></a>. Note however that using this function can lead to <b>identifiers no longer being unique across types</b>. They will still be unique and behave as expected within a certain type, but since some values of different types can physically equal, we may have identifer clashes:</p><pre class=\"language-ocaml\"><code>let _ = 97 == Obj.magic 'a' (* This is true *)\u000A\u000Amodule HMap = MakeHashconsedMap(Int)(HashedValue)\u000A\u000Alet m1 = HMap.singleton 5 97 (* int HMap.t *)\u000Alet m2 = HMap.singleton 5 'a' (* char HMap.t *)\u000Alet _ = HMap.get_id m1 = HMap.get_id m2 (* This is also true. *)</code></pre><p>This can cause problems if you wish to use identifiers of different map types together:</p><pre class=\"language-ocaml\"><code> module MapOfMaps = MakeMap(struct\u000A   type t = Any : 'a HMap.t -&gt; t\u000A   let to_int (Any x) = Node.get_id x\u000A end)\u000A\u000Alet m3 = MapOfMaps.of_list [ (m1, &quot;foo&quot;); (m2, &quot;bar&quot;) ]\u000A(* m3 has cardinal 1, the m1-&gt;foo binding has been overwritten. *)</code></pre><p>This issue does not happen with the two previous variants, since they both only return true on the same types.</p></li></ul></div></div>"}